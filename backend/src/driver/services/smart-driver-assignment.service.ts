import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Driver } from '../schemas/driver.schema';
import { Order } from '../../order/schemas/order.schema';
import { RedisService } from '../../common/services/redis.service';
import { OptimizedNotificationGateway } from '../../notification/optimized-notification.gateway';

interface DriverCandidate {
  driverId: string;
  distance: number;
  rating: number;
  activeOrdersCount: number;
  isAvailable: boolean;
  location?: { lat: number; lng: number };
}

@Injectable()
export class SmartDriverAssignmentService {
  private readonly logger = new Logger(SmartDriverAssignmentService.name);

  constructor(
    @InjectModel(Driver.name) private driverModel: Model<Driver>,
    @InjectModel(Order.name) private orderModel: Model<Order>,
    private redisService: RedisService,
    private notificationGateway: OptimizedNotificationGateway,
  ) {}

  /**
   * T√¨m t√†i x·∫ø ph√π h·ª£p nh·∫•t cho ƒë∆°n h√†ng
   */
  async findBestDriverForOrder(orderId: string): Promise<string | null> {
    try {
      this.logger.log(`üîç Finding best driver for order: ${orderId}`);

      // L·∫•y th√¥ng tin ƒë∆°n h√†ng
      const order = await this.orderModel.findById(orderId).lean();
      if (!order) {
        this.logger.error(`Order not found: ${orderId}`);
        return null;
      }

      // CH·ªà T√åM T√ÄI X·∫æ CHO ƒê∆†N CH∆ØA C√ì T√ÄI X·∫æ
      if (order.driverId) {
        this.logger.log(`Order ${orderId} already has driver: ${order.driverId}`);
        // X√≥a kh·ªèi pending orders
        await this.redisService.removePendingOrder(orderId);
        return null;
      }

      // L·∫•y t·∫•t c·∫£ t√†i x·∫ø available
      const availableDrivers = await this.getAvailableDrivers();
      if (availableDrivers.length === 0) {
        this.logger.warn('No available drivers found');
        return null;
      }

      // T√≠nh to√°n ƒëi·ªÉm s·ªë cho t·ª´ng t√†i x·∫ø
      const candidates: DriverCandidate[] = [];
      
      for (const driverId of availableDrivers) {
        const candidate = await this.evaluateDriver(driverId, order);
        if (candidate) {
          candidates.push(candidate);
        }
      }

      if (candidates.length === 0) {
        this.logger.warn('No suitable drivers found');
        return null;
      }

      // S·∫Øp x·∫øp theo ƒëi·ªÉm s·ªë (cao nh·∫•t tr∆∞·ªõc)
      candidates.sort((a, b) => this.calculateScore(b) - this.calculateScore(a));

      const bestDriver = candidates[0];
      this.logger.log(`Best driver found: ${bestDriver.driverId} with score: ${this.calculateScore(bestDriver)}`);

      return bestDriver.driverId;

    } catch (error) {
      this.logger.error('Error finding best driver:', error);
      return null;
    }
  }

  /**
   * ƒê√°nh gi√° t√†i x·∫ø d·ª±a tr√™n nhi·ªÅu ti√™u ch√≠
   */
  private async evaluateDriver(driverId: string, order: any): Promise<DriverCandidate | null> {
    try {
      // L·∫•y th√¥ng tin t√†i x·∫ø
      const driver = await this.driverModel.findById(driverId).lean();
      if (!driver) return null;

      // Ki·ªÉm tra t√†i x·∫ø c√≥ available kh√¥ng
      if (driver.status !== 'available') return null;

      // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i c·ªßa t√†i x·∫ø
      const location = await this.redisService.getDriverLocation(driverId);
      if (!location) {
        this.logger.warn(`No location data for driver: ${driverId}`);
        return null;
      }

      // T√≠nh kho·∫£ng c√°ch ƒë·∫øn nh√† h√†ng
      const distance = this.calculateDistance(
        location.lat, location.lng,
        order.restaurantId?.coordinates?.lat || 0,
        order.restaurantId?.coordinates?.lng || 0
      );

      // Ki·ªÉm tra kho·∫£ng c√°ch t·ªëi ƒëa (10km)
      if (distance > 10) return null;

      return {
        driverId,
        distance,
        rating: driver.rating || 4.0,
        activeOrdersCount: driver.activeOrdersCount || 0,
        isAvailable: true,
        location
      };

    } catch (error) {
      this.logger.error(`Error evaluating driver ${driverId}:`, error);
      return null;
    }
  }

  /**
   * T√≠nh ƒëi·ªÉm s·ªë t·ªïng h·ª£p cho t√†i x·∫ø
   */
  private calculateScore(candidate: DriverCandidate): number {
    // Tr·ªçng s·ªë cho t·ª´ng ti√™u ch√≠
    const distanceWeight = 0.4;    // Kho·∫£ng c√°ch (c√†ng g·∫ßn c√†ng t·ªët)
    const ratingWeight = 0.3;      // ƒê√°nh gi√° (c√†ng cao c√†ng t·ªët)
    const workloadWeight = 0.3;    // T·∫£i c√¥ng vi·ªác (c√†ng √≠t c√†ng t·ªët)

    // Chu·∫©n h√≥a kho·∫£ng c√°ch (0-10km -> 0-1, c√†ng g·∫ßn c√†ng cao)
    const distanceScore = Math.max(0, 1 - (candidate.distance / 10));

    // Chu·∫©n h√≥a rating (0-5 -> 0-1)
    const ratingScore = candidate.rating / 5;

    // Chu·∫©n h√≥a workload (0-5 ƒë∆°n -> 0-1, c√†ng √≠t c√†ng cao)
    const workloadScore = Math.max(0, 1 - (candidate.activeOrdersCount / 5));

    // T√≠nh ƒëi·ªÉm t·ªïng h·ª£p
    const totalScore = 
      distanceScore * distanceWeight +
      ratingScore * ratingWeight +
      workloadScore * workloadWeight;

    return totalScore;
  }

  /**
   * L·∫•y danh s√°ch t√†i x·∫ø available
   */
  private async getAvailableDrivers(): Promise<string[]> {
    // L·∫•y t·ª´ Redis cache tr∆∞·ªõc
    const cachedDrivers = await this.redisService.getAvailableDrivers();
    if (cachedDrivers.length > 0) {
      return cachedDrivers;
    }

    // N·∫øu kh√¥ng c√≥ cache, l·∫•y t·ª´ database
    const drivers = await this.driverModel
      .find({ status: 'available' })
      .select('_id')
      .lean();

    const driverIds = drivers.map(d => d._id.toString());
    
    // Cache v√†o Redis
    for (const driverId of driverIds) {
      await this.redisService.addAvailableDriver(driverId);
    }

    return driverIds;
  }

  /**
   * G√°n ƒë∆°n h√†ng cho t√†i x·∫ø
   */
  async assignOrderToDriver(orderId: string, driverId: string): Promise<boolean> {
    try {
      this.logger.log(`Assigning order ${orderId} to driver ${driverId}`);

      // C·∫≠p nh·∫≠t ƒë∆°n h√†ng
      await this.orderModel.findByIdAndUpdate(orderId, {
        driverId: new Types.ObjectId(driverId),
        status: 'picking_up',
        assignedAt: new Date()
      });

      // C·∫≠p nh·∫≠t t√†i x·∫ø
      await this.driverModel.findByIdAndUpdate(driverId, {
        status: 'delivering',
        currentOrderId: new Types.ObjectId(orderId),
        currentOrderStartedAt: new Date(),
        $inc: { activeOrdersCount: 1 }
      });

      // X√≥a kh·ªèi pending orders
      await this.redisService.removePendingOrder(orderId);

      // X√≥a kh·ªèi available drivers
      await this.redisService.removeAvailableDriver(driverId);

      // Cache assignment
      await this.redisService.setOrderAssignment(orderId, driverId);

      // G·ª≠i notification cho t√†i x·∫ø
      this.notificationGateway.notifyDriverAssigned(driverId, {
        orderId,
        message: 'B·∫°n c√≥ ƒë∆°n h√†ng m·ªõi!'
      });

      this.logger.log(`Order ${orderId} successfully assigned to driver ${driverId}`);
      return true;

    } catch (error) {
      this.logger.error(`Error assigning order ${orderId} to driver ${driverId}:`, error);
      return false;
    }
  }

  /**
   * X·ª≠ l√Ω t·∫•t c·∫£ ƒë∆°n h√†ng pending
   */
  async processPendingOrders(): Promise<void> {
    try {
      const pendingOrders = await this.redisService.getPendingOrders();
      this.logger.log(`Processing ${pendingOrders.length} pending orders`);

      for (const orderId of pendingOrders) {
        const bestDriver = await this.findBestDriverForOrder(orderId);
        
        if (bestDriver) {
          const success = await this.assignOrderToDriver(orderId, bestDriver);
          if (success) {
            this.logger.log(`Order ${orderId} assigned to driver ${bestDriver}`);
          }
        } else {
          this.logger.warn(`No suitable driver found for order ${orderId}`);
        }
      }

    } catch (error) {
      this.logger.error('Error processing pending orders:', error);
    }
  }

  /**
   * T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ƒëi·ªÉm (Haversine formula)
   */
  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
    const R = 6371; // B√°n k√≠nh Tr√°i ƒê·∫•t (km)
    const dLat = this.toRadians(lat2 - lat1);
    const dLng = this.toRadians(lng2 - lng1);
    
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) *
              Math.sin(dLng / 2) * Math.sin(dLng / 2);
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  private toRadians(degrees: number): number {
    return degrees * (Math.PI / 180);
  }
}
